
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/maddevsio/comedian/storage/mysql.go (83.5%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package storage

import (
        "time"

        // This line is must for working MySQL database
        _ "github.com/go-sql-driver/mysql"
        "github.com/labstack/gommon/log"

        "github.com/jmoiron/sqlx"
        "github.com/maddevsio/comedian/config"
        "github.com/maddevsio/comedian/model"
)

// MySQL provides api for work with mysql database
type MySQL struct {
        conn *sqlx.DB
}

// NewMySQL creates a new instance of database API
func NewMySQL(c config.Config) (*MySQL, error) <span class="cov8" title="1">{
        conn, err := sqlx.Open("mysql", c.DatabaseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">m := &amp;MySQL{}
        m.conn = conn
        return m, nil</span>
}

// CreateStandup creates standup entry in database
func (m *MySQL) CreateStandup(s model.Standup) (model.Standup, error) <span class="cov8" title="1">{
        err := s.Validate()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("ERROR: %s", err.Error())
                return s, err
        }</span>
        <span class="cov8" title="1">res, err := m.conn.Exec(
                "INSERT INTO `standup` (created, modified, username, comment, channel, channel_id, username_id, message_ts) VALUES (?, ?, ?, ?, ?, ?, ?, ?)",
                now().UTC(), now().UTC(), s.Username, s.Comment, s.Channel, s.ChannelID, s.UsernameID, s.MessageTS,
        )
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov8" title="1">id, err := res.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov8" title="1">s.ID = id
        return s, nil</span>
}

// UpdateStandup updates standup entry in database
func (m *MySQL) UpdateStandup(s model.Standup) (model.Standup, error) <span class="cov8" title="1">{
        err := s.Validate()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("ERROR: %s", err.Error())
                return s, err
        }</span>
        <span class="cov8" title="1">_, err = m.conn.Exec(
                "UPDATE `standup` SET modified=?, username=?, username_id=?, comment=?, channel=?, channel_id=?, message_ts=? WHERE id=?",
                now().UTC(), s.Username, s.UsernameID, s.Comment, s.Channel, s.ChannelID, s.MessageTS, s.ID,
        )
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov8" title="1">var i model.Standup
        err = m.conn.Get(&amp;i, "SELECT * FROM `standup` WHERE id=?", s.ID)
        return i, err</span>
}

// SelectStandup selects standup entry from database
func (m *MySQL) SelectStandup(id int64) (model.Standup, error) <span class="cov8" title="1">{
        var s model.Standup
        err := m.conn.Get(&amp;s, "SELECT * FROM `standup` WHERE id=?", id)
        return s, err
}</span>

// SelectStandupByMessageTS selects standup entry from database
func (m *MySQL) SelectStandupByMessageTS(messageTS string) (model.Standup, error) <span class="cov8" title="1">{
        var s model.Standup
        err := m.conn.Get(&amp;s, "SELECT * FROM `standup` WHERE message_ts=?", messageTS)
        return s, err
}</span>

// SelectStandupsByChannelID selects standup entry by channel ID from database
func (m *MySQL) SelectStandupsByChannelID(channelID string) ([]model.Standup, error) <span class="cov8" title="1">{
        items := []model.Standup{}
        err := m.conn.Select(&amp;items, "SELECT * FROM `standup` WHERE channel_id=?", channelID)
        return items, err
}</span>

// SelectStandupByChannelNameForPeriod selects standup entry by channel name and time period from database
func (m *MySQL) SelectStandupByChannelNameForPeriod(channelName string, dateStart,
        dateEnd time.Time) ([]model.Standup, error) <span class="cov8" title="1">{
        items := []model.Standup{}
        err := m.conn.Select(&amp;items, "SELECT * FROM `standup` WHERE channel=? AND created BETWEEN ? AND ?",
                channelName, dateStart, dateEnd)
        return items, err
}</span>

// SelectStandupsByChannelIDForPeriod selects standup entrys by channel ID and time period from database
func (m *MySQL) SelectStandupsByChannelIDForPeriod(channelID string, dateStart,
        dateEnd time.Time) ([]model.Standup, error) <span class="cov8" title="1">{
        items := []model.Standup{}
        err := m.conn.Select(&amp;items, "SELECT * FROM `standup` WHERE channel_id=? AND created BETWEEN ? AND ?",
                channelID, dateStart, dateEnd)
        return items, err
}</span>

// SelectStandupByUserNameForPeriod selects standup entrys by username and time period from database
func (m *MySQL) SelectStandupByUserNameForPeriod(username string, dateStart,
        dateEnd time.Time) ([]model.Standup, error) <span class="cov8" title="1">{
        items := []model.Standup{}
        err := m.conn.Select(&amp;items, "SELECT * FROM `standup` WHERE username=? AND created BETWEEN ? AND ? ",
                username, dateStart, dateEnd)
        return items, err
}</span>

// ListStandups returns array of standup entries from database
func (m *MySQL) ListStandups() ([]model.Standup, error) <span class="cov8" title="1">{
        items := []model.Standup{}
        err := m.conn.Select(&amp;items, "SELECT * FROM `standup`")
        return items, err
}</span>

// SelectStandupsForPeriod selects standup entrys for time period from database
func (m *MySQL) SelectStandupsForPeriod(dateStart, dateEnd time.Time) ([]model.Standup, error) <span class="cov8" title="1">{
        items := []model.Standup{}
        err := m.conn.Select(&amp;items, "SELECT * FROM `standup` WHERE created BETWEEN ? AND ?",
                dateStart, dateEnd)
        return items, err
}</span>

// DeleteStandup deletes standup entry from database
func (m *MySQL) DeleteStandup(id int64) error <span class="cov8" title="1">{
        _, err := m.conn.Exec("DELETE FROM `standup` WHERE id=?", id)
        return err
}</span>

// CreateStandupUser creates comedian entry in database
func (m *MySQL) CreateStandupUser(s model.StandupUser) (model.StandupUser, error) <span class="cov8" title="1">{
        err := s.Validate()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("ERROR: %s", err.Error())
                return s, err
        }</span>
        <span class="cov8" title="1">res, err := m.conn.Exec(
                "INSERT INTO `standup_users` (created, modified,slack_user_id, username, channel_id, channel) VALUES (?, ?, ?, ?, ?, ?)",
                now().UTC(), now().UTC(), s.SlackUserID, s.SlackName, s.ChannelID, s.Channel)
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov8" title="1">id, err := res.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov8" title="1">s.ID = id
        return s, nil</span>
}

//FindStandupUserInChannel finds user in channel
func (m *MySQL) FindStandupUserInChannel(username, channelID string) (model.StandupUser, error) <span class="cov8" title="1">{
        var u model.StandupUser
        err := m.conn.Get(&amp;u, "SELECT * FROM `standup_users` WHERE username=? AND channel_id=?", username, channelID)
        return u, err
}</span>

//FindStandupUserInChannelName finds user in channel
func (m *MySQL) FindStandupUserInChannelName(username, channel string) (model.StandupUser, error) <span class="cov8" title="1">{
        var u model.StandupUser
        err := m.conn.Get(&amp;u, "SELECT * FROM `standup_users` WHERE username=? AND channel=?", username, channel)
        return u, err
}</span>

//FindStandupUser finds user in
func (m *MySQL) FindStandupUser(username string) (model.StandupUser, error) <span class="cov8" title="1">{
        var u model.StandupUser
        err := m.conn.Get(&amp;u, "SELECT * FROM `standup_users` WHERE username=?", username)
        return u, err
}</span>

// ListAllStandupUsers returns array of standup entries from database
func (m *MySQL) ListAllStandupUsers() ([]model.StandupUser, error) <span class="cov8" title="1">{
        items := []model.StandupUser{}
        err := m.conn.Select(&amp;items, "SELECT * FROM `standup_users`")
        return items, err
}</span>

// ListStandupUsersByChannelID returns array of standup entries from database
func (m *MySQL) ListStandupUsersByChannelID(channelID string) ([]model.StandupUser, error) <span class="cov8" title="1">{
        items := []model.StandupUser{}
        err := m.conn.Select(&amp;items, "SELECT * FROM `standup_users` WHERE channel_id=?", channelID)
        return items, err
}</span>

// ListStandupUsersByChannelName returns array of standup entries from database filtered by channel name
func (m *MySQL) ListStandupUsersByChannelName(channelName string) ([]model.StandupUser, error) <span class="cov8" title="1">{
        items := []model.StandupUser{}
        err := m.conn.Select(&amp;items, "SELECT * FROM `standup_users` WHERE channel=?", channelName)
        return items, err
}</span>

// DeleteStandupUserByUsername deletes standup_users entry from database
func (m *MySQL) DeleteStandupUserByUsername(username, channelID string) error <span class="cov8" title="1">{
        _, err := m.conn.Exec("DELETE FROM `standup_users` WHERE username=? AND channel_id=?", username, channelID)
        return err
}</span>

// CreateStandupTime creates time entry in database
func (m *MySQL) CreateStandupTime(s model.StandupTime) (model.StandupTime, error) <span class="cov8" title="1">{
        err := s.Validate()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("ERROR: %s", err.Error())
                return s, err
        }</span>
        <span class="cov8" title="1">res, err := m.conn.Exec(
                "INSERT INTO `standup_time` (created, channel_id, channel, standuptime) VALUES (?, ?, ?, ?)",
                now().UTC(), s.ChannelID, s.Channel, s.Time)
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov8" title="1">id, err := res.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov8" title="1">s.ID = id
        return s, nil</span>
}

// ListStandupTime returns standup time entry from database
func (m *MySQL) ListStandupTime(channelID string) (model.StandupTime, error) <span class="cov8" title="1">{
        var time model.StandupTime
        err := m.conn.Get(&amp;time, "SELECT * FROM `standup_time` WHERE channel_id=?", channelID)
        return time, err
}</span>

// ListAllStandupTime returns standup time entry for all channels from database
func (m *MySQL) ListAllStandupTime() ([]model.StandupTime, error) <span class="cov8" title="1">{
        reminders := []model.StandupTime{}
        err := m.conn.Select(&amp;reminders, "SELECT * FROM `standup_time`")
        return reminders, err
}</span>

// DeleteStandupTime deletes standup_time entry for channel from database
func (m *MySQL) DeleteStandupTime(channelID string) error <span class="cov8" title="1">{
        _, err := m.conn.Exec("DELETE FROM `standup_time` WHERE channel_id=?", channelID)
        return err
}</span>

// AddToStandupHistory creates backup standup entry in standup_edit_history database
func (m *MySQL) AddToStandupHistory(s model.StandupEditHistory) (model.StandupEditHistory, error) <span class="cov8" title="1">{
        err := s.Validate()
        if err != nil </span><span class="cov0" title="0">{
                log.Errorf("ERROR: %s", err.Error())
                return s, err
        }</span>
        <span class="cov8" title="1">res, err := m.conn.Exec(
                "INSERT INTO `standup_edit_history` (created, standup_id, standup_text) VALUES (?, ?, ?)",
                now().UTC(), s.StandupID, s.StandupText)
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov8" title="1">id, err := res.LastInsertId()
        if err != nil </span><span class="cov0" title="0">{
                return s, err
        }</span>
        <span class="cov8" title="1">s.ID = id
        return s, nil</span>
}

var nowFunc func() time.Time

func init() <span class="cov8" title="1">{
        nowFunc = func() time.Time </span><span class="cov8" title="1">{
                return time.Now()
        }</span>
}

func now() time.Time <span class="cov8" title="1">{
        return nowFunc().UTC()
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
